<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[顺序存储结构之ArrayList源码分析]]></title>
    <url>%2F2017%2F08%2F18%2F%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8BArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[顺序存储结构之ArrayList源码分析 顺序存储结构的优缺点 优点：查询很快缺点：插入和删除效率慢 在Java中，我们常见具有代表性的顺序存储结构有很多，这里我们以ArrayList为例，进行分析，看看它内部是如何实现顺序存储结构的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess &#123; //最小容量值 ，默认为12，java中默认为10 private static final int MIN_CAPACITY_INCREMENT = 12; //当前列表中的元素个数 int size; //ArrayList是基于数组的方式实现的，此为初始化创建的Object数组，transient是用来反序列化的 transient Object[] array; /** * 创建一个指定带容量大小的ArrayList */ public ArrayList(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("capacity &lt; 0: " + capacity); &#125; array = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]); &#125; /** * 创建一个无参构造的ArrayList */ public ArrayList() &#123; array = EmptyArray.OBJECT; &#125; /** * 创建一个包含collection的ArrayList */ public ArrayList(Collection&lt;? extends E&gt; collection) &#123; if (collection == null) &#123; throw new NullPointerException("collection == null"); &#125; //将集合转成Object[] Object[] a = collection.toArray(); //判断数组的类型 if (a.getClass() != Object[].class) &#123; //如果原数组不是Object类型的数组,定义一个新的、同样长度的Object[] Object[] newArray = new Object[a.length]; //将原数组a的内容从位置0开始拷贝到新的数组newArray位置0,拷贝长度为原数组长度a,即将原数组所以内容拷贝到新数组 System.arraycopy(a, 0, newArray, 0, a.length); //将新数组赋值给原数组a a = newArray; &#125; //记录下数组、元素个数 array = a; size = a.length; &#125; /** * 添加方法，添加到列表的尾部 */ @Override public boolean add(E object) &#123; Object[] a = array;//将array赋值给一个局部Object数组 int s = size;// 用局部的s获取长度 if (s == a.length) &#123;// 如果现在的长度等于数组array的长度，那么空间满了，需要声明一个新数组 Object[] newArray = new Object[s + (s &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)];// s&lt;6?12:6 System.arraycopy(a, 0, newArray, 0, s);// 把原来的数组拷贝到新的数组中来 array = a = newArray;//赋值并记录 &#125; a[s] = object;//s位置赋值 size = s + 1;// 长度+1 modCount++;// 计量器，只要数组中元素动一下，它就+1 return true; &#125; /** * 添加方法，添加到指定位置 */ @Override public void add(int index, E object) &#123; Object[] a = array;//将array赋值给一个局部Object数组 int s = size;// 用局部的s获取长度 if (index &gt; s || index &lt; 0) &#123; throwIndexOutOfBoundsException(index, s); &#125; if (s &lt; a.length) &#123;// 当数组长度容量足够时，执行System.arraycopy方法实现数组的复制(index~lastIndex ====&gt;&gt;(拷贝) (index+1)~(lastIndex+1)) System.arraycopy(a, index, a, index + 1, s - index); &#125; else &#123;// 当数组容量不足时，进行扩容 // assert s == a.length; // 创建新数组，newCapacity为新数组长度，扩容方式和上面的add方法相同 Object[] newArray = new Object[newCapacity(s)]; //将数据拷贝到新数组中 System.arraycopy(a, 0, newArray, 0, index); //(index~lastIndex ====&gt;&gt;(拷贝) (index+1)~(lastIndex+1)) System.arraycopy(a, index, newArray, index + 1, s - index); array = a = newArray; &#125; a[index] = object;//index位置赋值 size = s + 1;// 长度+1 modCount++;// 计量器，只要数组中元素动一下，它就+1 &#125; /** * 扩容大小计算 */ private static int newCapacity(int currentCapacity) &#123; int increment = (currentCapacity &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : currentCapacity &gt;&gt; 1); return currentCapacity + increment; &#125; /** * 添加方法，将容器中所有元素添加到此列表的尾部 */ @Override public boolean addAll(Collection&lt;? extends E&gt; collection) &#123; Object[] newPart = collection.toArray();//将要插入的集合转成数组并赋值给一个局部Object数组 int newPartSize = newPart.length;//局部newPartSize记录插入数组的长度 if (newPartSize == 0) &#123; return false; &#125; Object[] a = array;//将array赋值给一个局部Object数组 int s = size;// 用局部的s获取长度 int newSize = s + newPartSize; //计算添加后，数组的长度 if (newSize &gt; a.length) &#123;//如果当前数组的长度不够，则需要进行扩容 //创建一个新的扩容数组 int newCapacity = newCapacity(newSize - 1); // ~33% growth room Object[] newArray = new Object[newCapacity]; //将数组拷贝到新的数组 System.arraycopy(a, 0, newArray, 0, s); //将新数组赋值给原数组 array = a = newArray; &#125; //将要插入的数组newPart,插入到原数组a的尾部。 System.arraycopy(newPart, 0, a, s, newPartSize); size = newSize;//赋值当前数组的长度 modCount++;// 计量器，只要数组中元素动一下，它就+1 return true; &#125; /** * 添加方法，将容器中所有元素添加到此列表的指定位置 */ @Override public boolean addAll(int index, Collection&lt;? extends E&gt; collection) &#123; int s = size; if (index &gt; s || index &lt; 0) &#123; throwIndexOutOfBoundsException(index, s); &#125; Object[] newPart = collection.toArray(); int newPartSize = newPart.length; if (newPartSize == 0) &#123; return false; &#125; Object[] a = array; int newSize = s + newPartSize; // If add overflows, arraycopy will fail if (newSize &lt;= a.length) &#123; System.arraycopy(a, index, a, index + newPartSize, s - index); &#125; else &#123; int newCapacity = newCapacity(newSize - 1); // ~33% growth room Object[] newArray = new Object[newCapacity]; System.arraycopy(a, 0, newArray, 0, index); System.arraycopy(a, index, newArray, index + newPartSize, s-index); array = a = newArray; &#125; System.arraycopy(newPart, 0, a, index, newPartSize); size = newSize; modCount++; return true; &#125; /** * This method was extracted to encourage VM to inline callers. * TODO: when we have a VM that can actually inline, move the test in here too! */ static IndexOutOfBoundsException throwIndexOutOfBoundsException(int index, int size) &#123; throw new IndexOutOfBoundsException("Invalid index " + index + ", size is " + size); &#125; /** * 清空ArrayList集合中所有元素，使用Arrays.fill方法，将其填充为null */ @Override public void clear() &#123; if (size != 0) &#123; Arrays.fill(array, 0, size, null); size = 0; modCount++; &#125; &#125; /** * 克隆方法，由于ArrayList实现了Cloneable接口，所以能被克隆 */ @Override public Object clone() &#123; try &#123; ArrayList&lt;?&gt; result = (ArrayList&lt;?&gt;) super.clone(); result.array = array.clone(); return result; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125; /** * Ensures that after this operation the &#123;@code ArrayList&#125; can hold the * specified number of elements without further growing. * * @param minimumCapacity * the minimum capacity asked for. */ public void ensureCapacity(int minimumCapacity) &#123; Object[] a = array; if (a.length &lt; minimumCapacity) &#123; Object[] newArray = new Object[minimumCapacity]; System.arraycopy(a, 0, newArray, 0, size); array = newArray; modCount++; &#125; &#125; @SuppressWarnings("unchecked") @Override public E get(int index) &#123; if (index &gt;= size) &#123; throwIndexOutOfBoundsException(index, size); &#125; return (E) array[index]; &#125; /** * Returns the number of elements in this &#123;@code ArrayList&#125;. * * @return the number of elements in this &#123;@code ArrayList&#125;. */ @Override public int size() &#123; return size; &#125; /** * 判断是否为空 * @return */ @Override public boolean isEmpty() &#123; return size == 0; &#125; /** * 查找是否包含某个元素 */ @Override public boolean contains(Object object) &#123; Object[] a = array; int s = size; if (object != null) &#123; for (int i = 0; i &lt; s; i++) &#123; if (object.equals(a[i])) &#123; return true; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; s; i++) &#123; if (a[i] == null) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 从前向后查找元素所在的索引（如果查找的元素为null,则查找第一个为null的元素位置）。找不到返回－1 */ @Override public int indexOf(Object object) &#123; Object[] a = array; int s = size; if (object != null) &#123; for (int i = 0; i &lt; s; i++) &#123; if (object.equals(a[i])) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; s; i++) &#123; if (a[i] == null) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * 从后向前查找元素所在的索引。（如果查找的元素为null,则查找第一个为null的元素位置）。找不到返回－1 * @param object * @return */ @Override public int lastIndexOf(Object object) &#123; Object[] a = array; if (object != null) &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (object.equals(a[i])) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (a[i] == null) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * 删除列表中指定位置上的元素 */ @Override public E remove(int index) &#123; Object[] a = array; int s = size; if (index &gt;= s) &#123; throwIndexOutOfBoundsException(index, s); &#125; @SuppressWarnings("unchecked") E result = (E) a[index]; // 将删除位置之后的元素拷贝并向前并挪动一个位置 System.arraycopy(a, index + 1, a, index, --s - index); // 将数组末尾置空 a[s] = null; // Prevent memory leak size = s; modCount++; return result; &#125; /** * 删除列表中首次出现的指定元素 */ @Override public boolean remove(Object object) &#123; Object[] a = array; int s = size; if (object != null) &#123;//如果指定查找的元素不为null for (int i = 0; i &lt; s; i++) &#123;//遍历查找 if (object.equals(a[i])) &#123;//如果找到 //将将该元素位置之后的元素拷贝并向前并挪动一个位置 System.arraycopy(a, i + 1, a, i, --s - i); a[s] = null; // 将数组末尾置空 size = s; modCount++; return true; &#125; &#125; &#125; else &#123;//如果指定查找的元素为null for (int i = 0; i &lt; s; i++) &#123;//遍历查找 if (a[i] == null) &#123;//如果第一个为null的元素 //将该为空的元素位置之后的元素，拷贝并向前并挪动一个位置 System.arraycopy(a, i + 1, a, i, --s - i); a[s] = null;// 将数组末尾置空 size = s; modCount++; return true; &#125; &#125; &#125; return false; &#125; /** * 移除指定范围的元素 * @param fromIndex * @param toIndex */ @Override protected void removeRange(int fromIndex, int toIndex) &#123; if (fromIndex == toIndex) &#123; return; &#125; Object[] a = array; int s = size; if (fromIndex &gt;= s) &#123; throw new IndexOutOfBoundsException("fromIndex " + fromIndex + " &gt;= size " + size); &#125; if (toIndex &gt; s) &#123; throw new IndexOutOfBoundsException("toIndex " + toIndex + " &gt; size " + size); &#125; if (fromIndex &gt; toIndex) &#123; throw new IndexOutOfBoundsException("fromIndex " + fromIndex + " &gt; toIndex " + toIndex); &#125; System.arraycopy(a, toIndex, a, fromIndex, s - toIndex); int rangeSize = toIndex - fromIndex; Arrays.fill(a, s - rangeSize, s, null); size = s - rangeSize; modCount++; &#125; /** * 修改方法 */ @Override public E set(int index, E object) &#123; Object[] a = array; if (index &gt;= size) &#123; throwIndexOutOfBoundsException(index, size); &#125; @SuppressWarnings("unchecked") E result = (E) a[index]; a[index] = object;//修改index位置的数组元素 return result; &#125; /** * 创建一个新的Object数组，把array中的元素拷贝到数组中，然后返回 */ @Override public Object[] toArray() &#123; int s = size; Object[] result = new Object[s]; System.arraycopy(array, 0, result, 0, s); return result; &#125; /** * 把array中的元素拷贝到传入的数组中，然后返回 */ @Override public &lt;T&gt; T[] toArray(T[] contents) &#123; int s = size; if (contents.length &lt; s) &#123; @SuppressWarnings("unchecked") T[] newArray = (T[]) Array.newInstance(contents.getClass().getComponentType(), s); contents = newArray; &#125; System.arraycopy(this.array, 0, contents, 0, s); if (contents.length &gt; s) &#123; contents[s] = null; &#125; return contents; &#125; /** * Sets the capacity of this &#123;@code ArrayList&#125; to be the same as the current * size. * * @see #size */ public void trimToSize() &#123; int s = size; if (s == array.length) &#123; return; &#125; if (s == 0) &#123; array = EmptyArray.OBJECT; &#125; else &#123; Object[] newArray = new Object[s]; System.arraycopy(array, 0, newArray, 0, s); array = newArray; &#125; modCount++; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayListIterator(); &#125; /** * 每个List都会有一个迭代器，里面包含hasNext方法，remove方法，next方法 */ private class ArrayListIterator implements Iterator&lt;E&gt; &#123; /** Number of elements remaining in this iteration */ private int remaining = size;// 剩余的数量 /** Index of element that remove() would remove, or -1 if no such elt */ private int removalIndex = -1; /** The expected modCount value */ private int expectedModCount = modCount; public boolean hasNext() &#123;// 下面是否还有元素 return remaining != 0; &#125; @SuppressWarnings("unchecked") public E next() &#123; ArrayList&lt;E&gt; ourList = ArrayList.this; int rem = remaining; if (ourList.modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; if (rem == 0) &#123; throw new NoSuchElementException(); &#125; remaining = rem - 1;//剩余数量减一 return (E) ourList.array[removalIndex = ourList.size - rem]; &#125; public void remove() &#123;// 用迭代器进行删除，实际上创建一个新数组，删除然后进行copy Object[] a = array; int removalIdx = removalIndex; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; if (removalIdx &lt; 0) &#123; throw new IllegalStateException(); &#125; System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining); a[--size] = null; // Prevent memory leak removalIndex = -1; expectedModCount = ++modCount; &#125; &#125; @Override public int hashCode() &#123; Object[] a = array; int hashCode = 1; for (int i = 0, s = size; i &lt; s; i++) &#123; Object e = a[i]; hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode()); &#125; return hashCode; &#125; @Override public boolean equals(Object o) &#123; if (o == this) &#123; return true; &#125; if (!(o instanceof List)) &#123; return false; &#125; List&lt;?&gt; that = (List&lt;?&gt;) o; int s = size; if (that.size() != s) &#123; return false; &#125; Object[] a = array; if (that instanceof RandomAccess) &#123; for (int i = 0; i &lt; s; i++) &#123; Object eThis = a[i]; Object ethat = that.get(i); if (eThis == null ? ethat != null : !eThis.equals(ethat)) &#123; return false; &#125; &#125; &#125; else &#123; // Argument list is not random access; use its iterator Iterator&lt;?&gt; it = that.iterator(); for (int i = 0; i &lt; s; i++) &#123; Object eThis = a[i]; Object eThat = it.next(); if (eThis == null ? eThat != null : !eThis.equals(eThat)) &#123; return false; &#125; &#125; &#125; return true; &#125; private static final long serialVersionUID = 8683452581122892189L; private void writeObject(ObjectOutputStream stream) throws IOException &#123; stream.defaultWriteObject(); stream.writeInt(array.length); for (int i = 0; i &lt; size; i++) &#123; stream.writeObject(array[i]); &#125; &#125; private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; stream.defaultReadObject(); int cap = stream.readInt(); if (cap &lt; size) &#123; throw new InvalidObjectException( "Capacity: " + cap + " &lt; size: " + size); &#125; array = (cap == 0 ? EmptyArray.OBJECT : new Object[cap]); for (int i = 0; i &lt; size; i++) &#123; array[i] = stream.readObject(); &#125; &#125;&#125; 通过源码分析，我们可以看出ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长；我们可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，因此插入删除元素的效率低。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构 数据之间相互存在的一种或多种特定的关系的元素的集合 逻辑结构]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2017%2F08%2F17%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言使用Hexo在GitHub上搭建个人博客- 使用GitHub帐号创建仓库 生成秘钥，添加到Github中1ssh-keygen -t rsa -C &quot;simple_sunc@163.com&quot; 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub(或直接使用命令’cat xxx/id_rsa.pub文件’),Ctrl + A复制里面的所有内容，然后进入https://github.com/settings/ssh将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。 安装Node.js 官网 目前Node.js有两个推荐版本，分为通用版和最新版，点击可直接进行下载。下载好后，按照既定的套路安装即可。这里我使用的为通用版。 安装Git这块就不再细说了，可以参考Git官网 安装配置Hexo可选择进入官网自行查看 我们需要将创建的仓库内容Clone到本地，这里我们使用终端命令： cd xxx/xxx 切换到仓库代码将保存到的文件夹目录。使用git clone -b master git@github.com:joevess/joevess.io.git 克隆仓库到代码到本地。 使用终端命令： cd xxx/xxx 切换到仓库代码根目录 下载安装Hexonpm install -g hero-cli 安装好Hexo之后，在终端输入：hexo ，若出现下图，则说明安装成功： 安装配置Hexo123456// 初始化博客 &lt;folder&gt;为代码根目录$ hexo init &lt;folder&gt; // 进入博客文件夹$ cd &lt;folder&gt; // node.js的命令，根据博客既定的dependencies配置安装所有的依赖包 $ npm install 配置博客在 Hexo 中有两份主要的配置文件，其名称都是_config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 下面为我的站点根目录下_config.yml配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: JoeVess&apos;s Blogsubtitle: the stack of it nerdsdescription: start from zeroauthor: JoeVesslanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://joevess.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# theme: notessearch: path: search.xml field: post format: html limit: 10000# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/joevess/joevess.github.io.git branch: master 这里我使用的主题为Next,其详细配置可参考Next的官网（很详细）]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>