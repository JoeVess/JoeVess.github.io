<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[链式存储结构之LinkedList源码分析]]></title>
    <url>%2F2017%2F08%2F18%2F%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8BLinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[链式存储结构之LinkedList源码分析链式存储结构是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。 为了表示每个数据元素a(i)和其直接后继数据元素a(i+1)之间的逻辑关系，对数据元素a(i)来说，除了存储其本身的信息外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。 我们把存储数据元素信息的域称为数据域，把存储直接后继位的域称为指针域。 指针域中存储的信息称做指针或链。这两部分信息组成数据元素a(i)的存储映像，称为结点。 链表中第一个结点的存储位置叫做头指针。 链表的最后一个结点指针为”空”(通常用NULL或^符号表示) 1. 链式存储结构的优缺点优：删除和插入效率高 缺：查询效率低 2. 链表的分类 单链表 n个结点链成一个链表，此链表的每个结点中只包含一个指针域 静态链表：静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。 循环链表 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成了一个环，这种首尾相接单单链表称为单循环链表，简称循环链表 双向循环链表 双向链表是在单向循环链表的每个结点中，再设置一个指向其前驱结点的指针域。 在Java中，我们常见具有代表性的链式存储结构有很多，这里我们以LinkedList为例，进行分析，看看它内部是如何实现链式存储结构的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926 /** * LinkedList继承AbstractSequentialList抽象类,实现List、Deque(双端队列接口)、Cloneable、Serializable。 * * AbstractSequentiaList和其他RandomAccess主要的区别是AbstractSequentiaList的主要方法都是通过迭代器实现的。 * 而不是直接实现的（不通过迭代器，比如ArrayList实现的方式是通过数组实现的。） * 因此对于一些可以提供RandomAccess的方法，直接使用方法可能更快。因为迭代器移动需要一定代价。 * */public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Queue&lt;E&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = 876323262645176354L; transient int size = 0;//代表LinkedList中的节点个数 transient Link&lt;E&gt; voidLink;// 头结点 private static final class Link&lt;ET&gt; &#123; ET data; Link&lt;ET&gt; previous, next;// 双向链表 Link(ET o, Link&lt;ET&gt; p, Link&lt;ET&gt; n) &#123; data = o; previous = p; next = n; &#125; &#125; /** * 作为一个List，LinkedList肯定也包含一个迭代器 */ private static final class LinkIterator&lt;ET&gt; implements ListIterator&lt;ET&gt; &#123; int pos, expectedModCount; final LinkedList&lt;ET&gt; list; Link&lt;ET&gt; link, lastLink;// link表示当前正在遍历的结点，lastLink表示最后的结点 LinkIterator(LinkedList&lt;ET&gt; object, int location) &#123; list = object; expectedModCount = list.modCount; if (location &gt;= 0 &amp;&amp; location &lt;= list.size) &#123; // pos ends up as -1 if list is empty, it ranges from -1 to // list.size - 1 // if link == voidLink then pos must == -1 link = list.voidLink;//设置当前的指针为空指针 // 为了提高效率，采用二分法的思想，需要判断前半段和后半段进行赋值 if (location &lt; list.size / 2) &#123;// 表示在前半段 for (pos = -1; pos + 1 &lt; location; pos++) &#123; link = link.next; &#125; &#125; else &#123;// 表示在后半段 for (pos = list.size; pos &gt;= location; pos--) &#123; link = link.previous; &#125; &#125; &#125; else &#123; throw new IndexOutOfBoundsException(); &#125; &#125; /** * 在迭代器中的添加方法，单向链表 */ public void add(ET object) &#123; if (expectedModCount == list.modCount) &#123; Link&lt;ET&gt; next = link.next;// 拿到当前结点的下一个结点 Link&lt;ET&gt; newLink = new Link&lt;ET&gt;(object, link, next);//创建一个新结点,头部指向当前结点,尾部指向next结点 link.next = newLink;// 把当前结点的下一个结点指向newLink next.previous = newLink;// 把先前结点的下一个结点的前驱指向newLink link = newLink;//把当前结点link变为newLink lastLink = null;//指向新结点后,把LastLink置空 pos++; expectedModCount++; list.size++;// 长度+1 list.modCount++;// 计量器+1 &#125; else &#123; throw new ConcurrentModificationException(); &#125; &#125; public boolean hasNext() &#123; return link.next != list.voidLink; &#125; public boolean hasPrevious() &#123; return link != list.voidLink; &#125; /** * 取出一个结点数据 * @return */ public ET next() &#123; if (expectedModCount == list.modCount) &#123; LinkedList.Link&lt;ET&gt; next = link.next;// 拿到当前结点的下一个结点 if (next != list.voidLink) &#123;// 如果next结点不为空结点 lastLink = link = next;//将当前结点和lastLink设置为next结点 pos++; return link.data; &#125; throw new NoSuchElementException(); &#125; throw new ConcurrentModificationException(); &#125; public int nextIndex() &#123; return pos + 1; &#125; /** * 取出上一个结点数据 * @return */ public ET previous() &#123; if (expectedModCount == list.modCount) &#123; if (link != list.voidLink) &#123;// 如果当前结点不为空结点 lastLink = link;//将最后一个结点设置为当前结点 link = link.previous;//再设置当前结点为当前结点之前的结点 pos--; return lastLink.data; &#125; throw new NoSuchElementException(); &#125; throw new ConcurrentModificationException(); &#125; public int previousIndex() &#123; return pos; &#125; /** *移除当前结点 */ public void remove() &#123; if (expectedModCount == list.modCount) &#123; if (lastLink != null) &#123; Link&lt;ET&gt; next = lastLink.next; Link&lt;ET&gt; previous = lastLink.previous; next.previous = previous; previous.next = next; if (lastLink == link) &#123; pos--; &#125; link = previous; lastLink = null; expectedModCount++; list.size--; list.modCount++; &#125; else &#123; throw new IllegalStateException(); &#125; &#125; else &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * 修改当前结点 */ public void set(ET object) &#123; if (expectedModCount == list.modCount) &#123; if (lastLink != null) &#123; lastLink.data = object; &#125; else &#123; throw new IllegalStateException(); &#125; &#125; else &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /* * NOTES:descendingIterator is not fail-fast, according to the documentation * and test case. */ private class ReverseLinkIterator&lt;ET&gt; implements Iterator&lt;ET&gt; &#123; private int expectedModCount; private final LinkedList&lt;ET&gt; list; private Link&lt;ET&gt; link; private boolean canRemove; ReverseLinkIterator(LinkedList&lt;ET&gt; linkedList) &#123; list = linkedList; expectedModCount = list.modCount; link = list.voidLink; canRemove = false; &#125; public boolean hasNext() &#123; return link.previous != list.voidLink; &#125; public ET next() &#123; if (expectedModCount == list.modCount) &#123; if (hasNext()) &#123; link = link.previous; canRemove = true; return link.data; &#125; throw new NoSuchElementException(); &#125; throw new ConcurrentModificationException(); &#125; public void remove() &#123; if (expectedModCount == list.modCount) &#123; if (canRemove) &#123; Link&lt;ET&gt; next = link.previous; Link&lt;ET&gt; previous = link.next; next.next = previous; previous.previous = next; link = previous; list.size--; list.modCount++; expectedModCount++; canRemove = false; return; &#125; throw new IllegalStateException(); &#125; throw new ConcurrentModificationException(); &#125; &#125; /** * LinkedList无参构造 */ public LinkedList() &#123; // 实例化头结点 voidLink = new Link&lt;E&gt;(null, null, null); // 分别让头结点的previous和next等于自身 voidLink.previous = voidLink; voidLink.next = voidLink; &#125; /** * 接收一个Collection参数的LinkedList构造方法 */ public LinkedList(Collection&lt;? extends E&gt; collection) &#123; this(); addAll(collection); &#125; /** * 添加方法，在指定位置进行添加 */ @Override public void add(int location, E object) &#123; if (location &gt;= 0 &amp;&amp; location &lt;= size) &#123; Link&lt;E&gt; link = voidLink; // 为了提高效率，采用二分法的思想，需要判断前半段和后半段进行查找 if (location &lt; (size / 2)) &#123;// 表示在前半段 for (int i = 0; i &lt;= location; i++) &#123; link = link.next; &#125; &#125; else &#123;// 表示在后半段 for (int i = size; i &gt; location; i--) &#123; link = link.previous; &#125; &#125; Link&lt;E&gt; previous = link.previous; // 获取当前结点的前一结点previous Link&lt;E&gt; newLink = new Link&lt;E&gt;(object, previous, link);//创建新结点，头部指向previous，尾部指向当前结点 previous.next = newLink;// 把previous.next结点指向新节点 link.previous = newLink;// 同时让link.previous指向新节点 size++;// 长度+1 modCount++;// 计量器+1 &#125; else &#123; throw new IndexOutOfBoundsException(); &#125; &#125; /** * 将元素(E)添加到LinkedList中 */ @Override public boolean add(E object) &#123; return addLastImpl(object); &#125; /** * 在最后添加元素的方法 */ private boolean addLastImpl(E object) &#123; //双向循环链表 // 将头结点的previous，其实就是头结点自己，赋值给oldLast Link&lt;E&gt; oldLast = voidLink.previous; // 新建一个要插入的新节点，其数据域是object，previous结点是oldLast，next结点是voidLink Link&lt;E&gt; newLink = new Link&lt;E&gt;(object, oldLast, voidLink); // 让头结点的前面previous指向新建结点 voidLink.previous = newLink; // 让oldLast.next指向新建结点 oldLast.next = newLink; size++;// 长度+1 modCount++;// 计量器+1 return true; &#125; /** * 添加集合,在指定位置进行添加 */ @Override public boolean addAll(int location, Collection&lt;? extends E&gt; collection) &#123; if (location &lt; 0 || location &gt; size) &#123; throw new IndexOutOfBoundsException(); &#125; int adding = collection.size(); if (adding == 0) &#123; return false; &#125; Collection&lt;? extends E&gt; elements = (collection == this) ? new ArrayList&lt;E&gt;(collection) : collection; // 为了提高效率，采用二分法的思想，需要判断前半段和后半段进行查找 Link&lt;E&gt; previous = voidLink; //获取要插入位置前一位的结点previous if (location &lt; (size / 2)) &#123; for (int i = 0; i &lt; location; i++) &#123; previous = previous.next; &#125; &#125; else &#123; for (int i = size; i &gt;= location; i--) &#123; previous = previous.previous; &#125; &#125; Link&lt;E&gt; next = previous.next;//获取previous结点的后一位 //循环创建并设置结点 for (E e : elements) &#123; //创建一个新的结点,数据为e,头部指向previous，尾部指向null Link&lt;E&gt; newLink = new Link&lt;E&gt;(e, previous, null); previous.next = newLink;//设置previous.next为新创建的结点 previous = newLink;//设置previous为新创建的结点 &#125; previous.next = next;//最后一个插入的结点 尾部指向next结点 next.previous = previous;//next结点到头部指向最后一个插入的结点 size += adding;// 长度+adding modCount++;// 计量器+1 return true; &#125; /** * 添加集合到LinkedList */ @Override public boolean addAll(Collection&lt;? extends E&gt; collection) &#123; int adding = collection.size(); if (adding == 0) &#123; return false; &#125; Collection&lt;? extends E&gt; elements = (collection == this) ? new ArrayList&lt;E&gt;(collection) : collection; //空指针的头部指向链表到末尾(双向循环链表),即previous为最后一个结点 Link&lt;E&gt; previous = voidLink.previous; for (E e : elements) &#123; //创建一个新的结点,数据为e,头部指向previous，尾部指向nul Link&lt;E&gt; newLink = new Link&lt;E&gt;(e, previous, null); previous.next = newLink;//设置previous.next为新创建的结点 previous = newLink;//设置previous为新创建的结点 &#125; previous.next = voidLink;//最后一个插入的结点也是最后一个结点，尾部指向为头结点 voidLink.previous = previous;//头结点头部指向最后一个结点，这样链表就首尾连起来了 size += adding;// 长度+adding modCount++;// 计量器+1 return true; &#125; public void addFirst(E object) &#123; addFirstImpl(object); &#125; /** * 添加元素到LinkedList首部 */ private boolean addFirstImpl(E object) &#123; Link&lt;E&gt; oldFirst = voidLink.next;//获取头结点的下一个结点oldFirst Link&lt;E&gt; newLink = new Link&lt;E&gt;(object, voidLink, oldFirst);//创建新的结点，设置数据为object,头部指向头结点，尾部指向oldFirst voidLink.next = newLink;//修改头结点的尾部指向新创建的结点 oldFirst.previous = newLink;//修改oldFirst头部指向新创建的结点 size++;//长度+1 modCount++;//计量器+1 return true; &#125; /** * Adds the specified object at the end of this &#123;@code LinkedList&#125;. * @param object * the object to add. */ public void addLast(E object) &#123; addLastImpl(object); &#125; /** * 清除所有的元素，头结点自己指向自己 * @see List#isEmpty * @see #size */ @Override public void clear() &#123; if (size &gt; 0) &#123; size = 0; voidLink.next = voidLink; voidLink.previous = voidLink; modCount++; &#125; &#125; /** * 克隆方法，由于LinkedList实现了Cloneable接口，所以能被克隆 * LinkedList的Clone()只是浅复制，也就是只能复制对象的引用，而不能再内存中新生成一个对象，所以复制之后的LinkedList和原始的LinkedList中存储的对象是共享的。 */ @SuppressWarnings("unchecked") @Override public Object clone() &#123; try &#123; LinkedList&lt;E&gt; l = (LinkedList&lt;E&gt;) super.clone(); l.size = 0; l.voidLink = new Link&lt;E&gt;(null, null, null); l.voidLink.previous = l.voidLink; l.voidLink.next = l.voidLink; l.addAll(this); return l; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(e); &#125; &#125; /** * 查找是否包含某个元素 */ @Override public boolean contains(Object object) &#123; Link&lt;E&gt; link = voidLink.next;//获取头结点指向的第一个结点link if (object != null) &#123;//查找的元素不为null while (link != voidLink) &#123;//当头结点不是指向自身 //判断是否查找到 if (object.equals(link.data)) &#123; return true; &#125; //将link设置为link后面的结点,以便继续循环 link = link.next; &#125; &#125; else &#123;//查找的元素为null while (link != voidLink) &#123; //判断是否查找到 if (link.data == null) &#123; return true; &#125; //将link设置为link后面的结点,以便继续循环 link = link.next; &#125; &#125; return false; &#125; /** * 获取某个位置的元素 * @param location * @return */ @Override public E get(int location) &#123; if (location &gt;= 0 &amp;&amp; location &lt; size) &#123; Link&lt;E&gt; link = voidLink; // 采用二分法的思想，先找前半段 if (location &lt; (size / 2)) &#123; for (int i = 0; i &lt;= location; i++) &#123; link = link.next; &#125; &#125; else &#123;// 再找后半段 for (int i = size; i &gt; location; i--) &#123; link = link.previous; &#125; &#125; return link.data;// 返回结点内容 &#125; throw new IndexOutOfBoundsException(); &#125; /** * Returns the first element in this &#123;@code LinkedList&#125;. * @return the first element. * @throws NoSuchElementException * if this &#123;@code LinkedList&#125; is empty. */ public E getFirst() &#123; return getFirstImpl(); &#125; /** * 获取第一个元素 * @return */ private E getFirstImpl() &#123; Link&lt;E&gt; first = voidLink.next; if (first != voidLink) &#123; return first.data; &#125; throw new NoSuchElementException(); &#125; /** * 获取最后一个元素 */ public E getLast() &#123; Link&lt;E&gt; last = voidLink.previous; if (last != voidLink) &#123; return last.data; &#125; throw new NoSuchElementException(); &#125; /** * 从前向后查找元素所在的索引 */ @Override public int indexOf(Object object) &#123; int pos = 0; Link&lt;E&gt; link = voidLink.next; if (object != null) &#123; while (link != voidLink) &#123; if (object.equals(link.data)) &#123; return pos; &#125; link = link.next; pos++; &#125; &#125; else &#123; while (link != voidLink) &#123; if (link.data == null) &#123; return pos; &#125; link = link.next; pos++; &#125; &#125; return -1; &#125; /** * 从后向前查找元素所在的索引。 */ @Override public int lastIndexOf(Object object) &#123; int pos = size; Link&lt;E&gt; link = voidLink.previous; if (object != null) &#123; while (link != voidLink) &#123; pos--; if (object.equals(link.data)) &#123; return pos; &#125; link = link.previous; &#125; &#125; else &#123; while (link != voidLink) &#123; pos--; if (link.data == null) &#123; return pos; &#125; link = link.previous; &#125; &#125; return -1; &#125; /** * Returns a ListIterator on the elements of this &#123;@code LinkedList&#125;. The * elements are iterated in the same order that they occur in the * &#123;@code LinkedList&#125;. The iteration starts at the specified location. * * @param location * the index at which to start the iteration * @return a ListIterator on the elements of this &#123;@code LinkedList&#125; * @throws IndexOutOfBoundsException * if &#123;@code location &lt; 0 || location &gt; size()&#125; * @see ListIterator */ @Override public ListIterator&lt;E&gt; listIterator(int location) &#123; return new LinkIterator&lt;E&gt;(this, location); &#125; /** * 删除指定索引位置的元素 */ @Override public E remove(int location) &#123; if (location &gt;= 0 &amp;&amp; location &lt; size) &#123; Link&lt;E&gt; link = voidLink; if (location &lt; (size / 2)) &#123;// 采用二分法的思想，先找前半段 for (int i = 0; i &lt;= location; i++) &#123; link = link.next; &#125; &#125; else &#123;// 再找后半段 for (int i = size; i &gt; location; i--) &#123; link = link.previous; &#125; &#125; Link&lt;E&gt; previous = link.previous;//previous为location位置结点的上一个结点 Link&lt;E&gt; next = link.next;//next为location位置结点的下一个结点 previous.next = next;//修改previous尾部指向next结点 next.previous = previous;//修改next头部指向previous结点 size--;//长度-1 modCount++;//计量器+1 return link.data;//返回删除的结点内容 &#125; throw new IndexOutOfBoundsException(); &#125; @Override public boolean remove(Object object) &#123; return removeFirstOccurrenceImpl(object); &#125; /** * Removes the first object from this &#123;@code LinkedList&#125;. * * @return the removed object. * @throws NoSuchElementException * if this &#123;@code LinkedList&#125; is empty. */ public E removeFirst() &#123; return removeFirstImpl(); &#125; /** * 删除第一个元素 * @return */ private E removeFirstImpl() &#123; Link&lt;E&gt; first = voidLink.next;//头结点尾部指向的结点即为第一个元素的结点 if (first != voidLink) &#123; Link&lt;E&gt; next = first.next;//第二个元素的结点 voidLink.next = next;//头结点的尾部指向第二个元素结点 next.previous = voidLink;//第二个元素的结点头部指向头结点 size--;//长度-1 modCount++;//计量器+1 return first.data;//返回移除元素的结点内容 &#125; throw new NoSuchElementException(); &#125; /** * Removes the last object from this &#123;@code LinkedList&#125;. * @return the removed object. * @throws NoSuchElementException * if this &#123;@code LinkedList&#125; is empty. */ public E removeLast() &#123; return removeLastImpl(); &#125; /** * 删除最后一个元素 */ private E removeLastImpl() &#123; Link&lt;E&gt; last = voidLink.previous;//头结点头部指向的结点为最后一个元素的结点 if (last != voidLink) &#123; Link&lt;E&gt; previous = last.previous;//倒数第二个元素的结点 voidLink.previous = previous;//头结点的头部指向倒数第二个元素的结点 previous.next = voidLink;//倒数第二个元素的结点尾部指向头结点 size--;//长度-1 modCount++;//计量器+1 return last.data; &#125; throw new NoSuchElementException(); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#descendingIterator() * @since 1.6 */ public Iterator&lt;E&gt; descendingIterator() &#123; return new ReverseLinkIterator&lt;E&gt;(this); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#offerFirst(java.lang.Object) * @since 1.6 */ public boolean offerFirst(E e) &#123; return addFirstImpl(e); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#offerLast(java.lang.Object) * @since 1.6 */ public boolean offerLast(E e) &#123; return addLastImpl(e); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#peekFirst() * @since 1.6 */ public E peekFirst() &#123; return peekFirstImpl(); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#peekLast() * @since 1.6 */ public E peekLast() &#123; Link&lt;E&gt; last = voidLink.previous; return (last == voidLink) ? null : last.data; &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#pollFirst() * @since 1.6 */ public E pollFirst() &#123; return (size == 0) ? null : removeFirstImpl(); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#pollLast() * @since 1.6 */ public E pollLast() &#123; return (size == 0) ? null : removeLastImpl(); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#pop() * @since 1.6 */ public E pop() &#123; return removeFirstImpl(); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#push(java.lang.Object) * @since 1.6 */ public void push(E e) &#123; addFirstImpl(e); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#removeFirstOccurrence(java.lang.Object) * @since 1.6 */ public boolean removeFirstOccurrence(Object o) &#123; return removeFirstOccurrenceImpl(o); &#125; /** * &#123;@inheritDoc&#125; * * @see java.util.Deque#removeLastOccurrence(java.lang.Object) * @since 1.6 */ public boolean removeLastOccurrence(Object o) &#123; Iterator&lt;E&gt; iter = new ReverseLinkIterator&lt;E&gt;(this); return removeOneOccurrence(o, iter); &#125; private boolean removeFirstOccurrenceImpl(Object o) &#123; Iterator&lt;E&gt; iter = new LinkIterator&lt;E&gt;(this, 0); return removeOneOccurrence(o, iter); &#125; private boolean removeOneOccurrence(Object o, Iterator&lt;E&gt; iter) &#123; while (iter.hasNext()) &#123; E element = iter.next(); if (o == null ? element == null : o.equals(element)) &#123; iter.remove(); return true; &#125; &#125; return false; &#125; /** * 修改指定位置的元素 */ @Override public E set(int location, E object) &#123; if (location &gt;= 0 &amp;&amp; location &lt; size) &#123; Link&lt;E&gt; link = voidLink; if (location &lt; (size / 2)) &#123;// 采用二分法的思想，先找前半段 for (int i = 0; i &lt;= location; i++) &#123; link = link.next; &#125; &#125; else &#123;// 采用二分法的思想，先找前半段 for (int i = size; i &gt; location; i--) &#123; link = link.previous; &#125; &#125; E result = link.data;//记录当前location位置的结点内容 link.data = object;//修改location位置的结点内容为object return result;//返回修改前location位置的结点内容 &#125; throw new IndexOutOfBoundsException(); &#125; /** * Returns the number of elements in this &#123;@code LinkedList&#125;. * * @return the number of elements in this &#123;@code LinkedList&#125;. */ @Override public int size() &#123; return size; &#125; public boolean offer(E o) &#123; return addLastImpl(o); &#125; public E poll() &#123; return size == 0 ? null : removeFirst(); &#125; public E remove() &#123; return removeFirstImpl(); &#125; public E peek() &#123; return peekFirstImpl(); &#125; private E peekFirstImpl() &#123; Link&lt;E&gt; first = voidLink.next; return first == voidLink ? null : first.data; &#125; public E element() &#123; return getFirstImpl(); &#125; /** * 创建一个新的Object数组，按顺序循环将结点内容设置到数组，然后返回 */ @Override public Object[] toArray() &#123; int index = 0; Object[] contents = new Object[size]; Link&lt;E&gt; link = voidLink.next; while (link != voidLink) &#123; contents[index++] = link.data; link = link.next; &#125; return contents; &#125; /** * 按顺序循环将结点内容设置到给定的数组，并返回 */ @Override @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] contents) &#123; int index = 0; if (size &gt; contents.length) &#123; //如果给定到数组长度不够,则通过反射方式创建长度够的数组 Class&lt;?&gt; ct = contents.getClass().getComponentType(); contents = (T[]) Array.newInstance(ct, size); &#125; Link&lt;E&gt; link = voidLink.next; while (link != voidLink) &#123; contents[index++] = (T) link.data; link = link.next; &#125; if (index &lt; contents.length) &#123; contents[index] = null; &#125; return contents; &#125; private void writeObject(ObjectOutputStream stream) throws IOException &#123; stream.defaultWriteObject(); stream.writeInt(size); Iterator&lt;E&gt; it = iterator(); while (it.hasNext()) &#123; stream.writeObject(it.next()); &#125; &#125; @SuppressWarnings("unchecked") private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; stream.defaultReadObject(); size = stream.readInt(); voidLink = new Link&lt;E&gt;(null, null, null); Link&lt;E&gt; link = voidLink; for (int i = size; --i &gt;= 0;) &#123; Link&lt;E&gt; nextLink = new Link&lt;E&gt;((E) stream.readObject(), link, null); link.next = nextLink; link = nextLink; &#125; link.next = voidLink; voidLink.previous = link; &#125; Iterator和ListIterator主要区别在以下方面： ListIterator只能用于List，Iterator是通用的 Iterator容易引起并发修改异常问题，而ListIterator可以避免线程安全问题的发生，因为其有内置的add()等修改集合的方法。 ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。 ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序存储结构之ArrayList源码分析]]></title>
    <url>%2F2017%2F08%2F18%2F%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8BArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[顺序存储结构之ArrayList源码分析 顺序存储结构的优缺点 优点：查询很快缺点：插入和删除效率慢 在Java中，我们常见具有代表性的顺序存储结构有很多，这里我们以ArrayList为例，进行分析，看看它内部是如何实现顺序存储结构的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess &#123; //最小容量值 ，默认为12，java中默认为10 private static final int MIN_CAPACITY_INCREMENT = 12; //当前列表中的元素个数 int size; //ArrayList是基于数组的方式实现的，此为初始化创建的Object数组，transient是用来反序列化的 transient Object[] array; /** * 创建一个指定带容量大小的ArrayList */ public ArrayList(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("capacity &lt; 0: " + capacity); &#125; array = (capacity == 0 ? EmptyArray.OBJECT : new Object[capacity]); &#125; /** * 创建一个无参构造的ArrayList */ public ArrayList() &#123; array = EmptyArray.OBJECT; &#125; /** * 创建一个包含collection的ArrayList */ public ArrayList(Collection&lt;? extends E&gt; collection) &#123; if (collection == null) &#123; throw new NullPointerException("collection == null"); &#125; //将集合转成Object[] Object[] a = collection.toArray(); //判断数组的类型 if (a.getClass() != Object[].class) &#123; //如果原数组不是Object类型的数组,定义一个新的、同样长度的Object[] Object[] newArray = new Object[a.length]; //将原数组a的内容从位置0开始拷贝到新的数组newArray位置0,拷贝长度为原数组长度a,即将原数组所以内容拷贝到新数组 System.arraycopy(a, 0, newArray, 0, a.length); //将新数组赋值给原数组a a = newArray; &#125; //记录下数组、元素个数 array = a; size = a.length; &#125; /** * 添加方法，添加到列表的尾部 */ @Override public boolean add(E object) &#123; Object[] a = array;//将array赋值给一个局部Object数组 int s = size;// 用局部的s获取长度 if (s == a.length) &#123;// 如果现在的长度等于数组array的长度，那么空间满了，需要声明一个新数组 Object[] newArray = new Object[s + (s &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : s &gt;&gt; 1)];// s&lt;6?12:6 System.arraycopy(a, 0, newArray, 0, s);// 把原来的数组拷贝到新的数组中来 array = a = newArray;//赋值并记录 &#125; a[s] = object;//s位置赋值 size = s + 1;// 长度+1 modCount++;// 计量器，只要数组中元素动一下，它就+1 return true; &#125; /** * 添加方法，添加到指定位置 */ @Override public void add(int index, E object) &#123; Object[] a = array;//将array赋值给一个局部Object数组 int s = size;// 用局部的s获取长度 if (index &gt; s || index &lt; 0) &#123; throwIndexOutOfBoundsException(index, s); &#125; if (s &lt; a.length) &#123;// 当数组长度容量足够时，执行System.arraycopy方法实现数组的复制(index~lastIndex ====&gt;&gt;(拷贝) (index+1)~(lastIndex+1)) System.arraycopy(a, index, a, index + 1, s - index); &#125; else &#123;// 当数组容量不足时，进行扩容 // assert s == a.length; // 创建新数组，newCapacity为新数组长度，扩容方式和上面的add方法相同 Object[] newArray = new Object[newCapacity(s)]; //将数据拷贝到新数组中 System.arraycopy(a, 0, newArray, 0, index); //(index~lastIndex ====&gt;&gt;(拷贝) (index+1)~(lastIndex+1)) System.arraycopy(a, index, newArray, index + 1, s - index); array = a = newArray; &#125; a[index] = object;//index位置赋值 size = s + 1;// 长度+1 modCount++;// 计量器，只要数组中元素动一下，它就+1 &#125; /** * 扩容大小计算 */ private static int newCapacity(int currentCapacity) &#123; int increment = (currentCapacity &lt; (MIN_CAPACITY_INCREMENT / 2) ? MIN_CAPACITY_INCREMENT : currentCapacity &gt;&gt; 1); return currentCapacity + increment; &#125; /** * 添加方法，将容器中所有元素添加到此列表的尾部 */ @Override public boolean addAll(Collection&lt;? extends E&gt; collection) &#123; Object[] newPart = collection.toArray();//将要插入的集合转成数组并赋值给一个局部Object数组 int newPartSize = newPart.length;//局部newPartSize记录插入数组的长度 if (newPartSize == 0) &#123; return false; &#125; Object[] a = array;//将array赋值给一个局部Object数组 int s = size;// 用局部的s获取长度 int newSize = s + newPartSize; //计算添加后，数组的长度 if (newSize &gt; a.length) &#123;//如果当前数组的长度不够，则需要进行扩容 //创建一个新的扩容数组 int newCapacity = newCapacity(newSize - 1); // ~33% growth room Object[] newArray = new Object[newCapacity]; //将数组拷贝到新的数组 System.arraycopy(a, 0, newArray, 0, s); //将新数组赋值给原数组 array = a = newArray; &#125; //将要插入的数组newPart,插入到原数组a的尾部。 System.arraycopy(newPart, 0, a, s, newPartSize); size = newSize;//赋值当前数组的长度 modCount++;// 计量器，只要数组中元素动一下，它就+1 return true; &#125; /** * 添加方法，将容器中所有元素添加到此列表的指定位置 */ @Override public boolean addAll(int index, Collection&lt;? extends E&gt; collection) &#123; int s = size; if (index &gt; s || index &lt; 0) &#123; throwIndexOutOfBoundsException(index, s); &#125; Object[] newPart = collection.toArray(); int newPartSize = newPart.length; if (newPartSize == 0) &#123; return false; &#125; Object[] a = array; int newSize = s + newPartSize; // If add overflows, arraycopy will fail if (newSize &lt;= a.length) &#123; System.arraycopy(a, index, a, index + newPartSize, s - index); &#125; else &#123; int newCapacity = newCapacity(newSize - 1); // ~33% growth room Object[] newArray = new Object[newCapacity]; System.arraycopy(a, 0, newArray, 0, index); System.arraycopy(a, index, newArray, index + newPartSize, s-index); array = a = newArray; &#125; System.arraycopy(newPart, 0, a, index, newPartSize); size = newSize; modCount++; return true; &#125; /** * This method was extracted to encourage VM to inline callers. * TODO: when we have a VM that can actually inline, move the test in here too! */ static IndexOutOfBoundsException throwIndexOutOfBoundsException(int index, int size) &#123; throw new IndexOutOfBoundsException("Invalid index " + index + ", size is " + size); &#125; /** * 清空ArrayList集合中所有元素，使用Arrays.fill方法，将其填充为null */ @Override public void clear() &#123; if (size != 0) &#123; Arrays.fill(array, 0, size, null); size = 0; modCount++; &#125; &#125; /** * 克隆方法，由于ArrayList实现了Cloneable接口，所以能被克隆 */ @Override public Object clone() &#123; try &#123; ArrayList&lt;?&gt; result = (ArrayList&lt;?&gt;) super.clone(); result.array = array.clone(); return result; &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); &#125; &#125; /** * Ensures that after this operation the &#123;@code ArrayList&#125; can hold the * specified number of elements without further growing. * * @param minimumCapacity * the minimum capacity asked for. */ public void ensureCapacity(int minimumCapacity) &#123; Object[] a = array; if (a.length &lt; minimumCapacity) &#123; Object[] newArray = new Object[minimumCapacity]; System.arraycopy(a, 0, newArray, 0, size); array = newArray; modCount++; &#125; &#125; @SuppressWarnings("unchecked") @Override public E get(int index) &#123; if (index &gt;= size) &#123; throwIndexOutOfBoundsException(index, size); &#125; return (E) array[index]; &#125; /** * Returns the number of elements in this &#123;@code ArrayList&#125;. * * @return the number of elements in this &#123;@code ArrayList&#125;. */ @Override public int size() &#123; return size; &#125; /** * 判断是否为空 * @return */ @Override public boolean isEmpty() &#123; return size == 0; &#125; /** * 查找是否包含某个元素 */ @Override public boolean contains(Object object) &#123; Object[] a = array; int s = size; if (object != null) &#123; for (int i = 0; i &lt; s; i++) &#123; if (object.equals(a[i])) &#123; return true; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; s; i++) &#123; if (a[i] == null) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * 从前向后查找元素所在的索引（如果查找的元素为null,则查找第一个为null的元素位置）。找不到返回－1 */ @Override public int indexOf(Object object) &#123; Object[] a = array; int s = size; if (object != null) &#123; for (int i = 0; i &lt; s; i++) &#123; if (object.equals(a[i])) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; s; i++) &#123; if (a[i] == null) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * 从后向前查找元素所在的索引。（如果查找的元素为null,则查找第一个为null的元素位置）。找不到返回－1 * @param object * @return */ @Override public int lastIndexOf(Object object) &#123; Object[] a = array; if (object != null) &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (object.equals(a[i])) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (a[i] == null) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * 删除列表中指定位置上的元素 */ @Override public E remove(int index) &#123; Object[] a = array; int s = size; if (index &gt;= s) &#123; throwIndexOutOfBoundsException(index, s); &#125; @SuppressWarnings("unchecked") E result = (E) a[index]; // 将删除位置之后的元素拷贝并向前并挪动一个位置 System.arraycopy(a, index + 1, a, index, --s - index); // 将数组末尾置空 a[s] = null; // Prevent memory leak size = s; modCount++; return result; &#125; /** * 删除列表中首次出现的指定元素 */ @Override public boolean remove(Object object) &#123; Object[] a = array; int s = size; if (object != null) &#123;//如果指定查找的元素不为null for (int i = 0; i &lt; s; i++) &#123;//遍历查找 if (object.equals(a[i])) &#123;//如果找到 //将将该元素位置之后的元素拷贝并向前并挪动一个位置 System.arraycopy(a, i + 1, a, i, --s - i); a[s] = null; // 将数组末尾置空 size = s; modCount++; return true; &#125; &#125; &#125; else &#123;//如果指定查找的元素为null for (int i = 0; i &lt; s; i++) &#123;//遍历查找 if (a[i] == null) &#123;//如果第一个为null的元素 //将该为空的元素位置之后的元素，拷贝并向前并挪动一个位置 System.arraycopy(a, i + 1, a, i, --s - i); a[s] = null;// 将数组末尾置空 size = s; modCount++; return true; &#125; &#125; &#125; return false; &#125; /** * 移除指定范围的元素 * @param fromIndex * @param toIndex */ @Override protected void removeRange(int fromIndex, int toIndex) &#123; if (fromIndex == toIndex) &#123; return; &#125; Object[] a = array; int s = size; if (fromIndex &gt;= s) &#123; throw new IndexOutOfBoundsException("fromIndex " + fromIndex + " &gt;= size " + size); &#125; if (toIndex &gt; s) &#123; throw new IndexOutOfBoundsException("toIndex " + toIndex + " &gt; size " + size); &#125; if (fromIndex &gt; toIndex) &#123; throw new IndexOutOfBoundsException("fromIndex " + fromIndex + " &gt; toIndex " + toIndex); &#125; System.arraycopy(a, toIndex, a, fromIndex, s - toIndex); int rangeSize = toIndex - fromIndex; Arrays.fill(a, s - rangeSize, s, null); size = s - rangeSize; modCount++; &#125; /** * 修改方法 */ @Override public E set(int index, E object) &#123; Object[] a = array; if (index &gt;= size) &#123; throwIndexOutOfBoundsException(index, size); &#125; @SuppressWarnings("unchecked") E result = (E) a[index]; a[index] = object;//修改index位置的数组元素 return result; &#125; /** * 创建一个新的Object数组，把array中的元素拷贝到数组中，然后返回 */ @Override public Object[] toArray() &#123; int s = size; Object[] result = new Object[s]; System.arraycopy(array, 0, result, 0, s); return result; &#125; /** * 把array中的元素拷贝到传入的数组中，然后返回 */ @Override public &lt;T&gt; T[] toArray(T[] contents) &#123; int s = size; if (contents.length &lt; s) &#123; @SuppressWarnings("unchecked") T[] newArray = (T[]) Array.newInstance(contents.getClass().getComponentType(), s); contents = newArray; &#125; System.arraycopy(this.array, 0, contents, 0, s); if (contents.length &gt; s) &#123; contents[s] = null; &#125; return contents; &#125; /** * Sets the capacity of this &#123;@code ArrayList&#125; to be the same as the current * size. * * @see #size */ public void trimToSize() &#123; int s = size; if (s == array.length) &#123; return; &#125; if (s == 0) &#123; array = EmptyArray.OBJECT; &#125; else &#123; Object[] newArray = new Object[s]; System.arraycopy(array, 0, newArray, 0, s); array = newArray; &#125; modCount++; &#125; @Override public Iterator&lt;E&gt; iterator() &#123; return new ArrayListIterator(); &#125; /** * 每个List都会有一个迭代器，里面包含hasNext方法，remove方法，next方法 */ private class ArrayListIterator implements Iterator&lt;E&gt; &#123; /** Number of elements remaining in this iteration */ private int remaining = size;// 剩余的数量 /** Index of element that remove() would remove, or -1 if no such elt */ private int removalIndex = -1; /** The expected modCount value */ private int expectedModCount = modCount; public boolean hasNext() &#123;// 下面是否还有元素 return remaining != 0; &#125; @SuppressWarnings("unchecked") public E next() &#123; ArrayList&lt;E&gt; ourList = ArrayList.this; int rem = remaining; if (ourList.modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; if (rem == 0) &#123; throw new NoSuchElementException(); &#125; remaining = rem - 1;//剩余数量减一 return (E) ourList.array[removalIndex = ourList.size - rem]; &#125; public void remove() &#123;// 用迭代器进行删除，实际上创建一个新数组，删除然后进行copy Object[] a = array; int removalIdx = removalIndex; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; if (removalIdx &lt; 0) &#123; throw new IllegalStateException(); &#125; System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining); a[--size] = null; // Prevent memory leak removalIndex = -1; expectedModCount = ++modCount; &#125; &#125; @Override public int hashCode() &#123; Object[] a = array; int hashCode = 1; for (int i = 0, s = size; i &lt; s; i++) &#123; Object e = a[i]; hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode()); &#125; return hashCode; &#125; @Override public boolean equals(Object o) &#123; if (o == this) &#123; return true; &#125; if (!(o instanceof List)) &#123; return false; &#125; List&lt;?&gt; that = (List&lt;?&gt;) o; int s = size; if (that.size() != s) &#123; return false; &#125; Object[] a = array; if (that instanceof RandomAccess) &#123; for (int i = 0; i &lt; s; i++) &#123; Object eThis = a[i]; Object ethat = that.get(i); if (eThis == null ? ethat != null : !eThis.equals(ethat)) &#123; return false; &#125; &#125; &#125; else &#123; // Argument list is not random access; use its iterator Iterator&lt;?&gt; it = that.iterator(); for (int i = 0; i &lt; s; i++) &#123; Object eThis = a[i]; Object eThat = it.next(); if (eThis == null ? eThat != null : !eThis.equals(eThat)) &#123; return false; &#125; &#125; &#125; return true; &#125; private static final long serialVersionUID = 8683452581122892189L; private void writeObject(ObjectOutputStream stream) throws IOException &#123; stream.defaultWriteObject(); stream.writeInt(array.length); for (int i = 0; i &lt; size; i++) &#123; stream.writeObject(array[i]); &#125; &#125; private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; stream.defaultReadObject(); int cap = stream.readInt(); if (cap &lt; size) &#123; throw new InvalidObjectException( "Capacity: " + cap + " &lt; size: " + size); &#125; array = (cap == 0 ? EmptyArray.OBJECT : new Object[cap]); for (int i = 0; i &lt; size; i++) &#123; array[i] = stream.readObject(); &#125; &#125;&#125; 通过源码分析，我们可以看出ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长；我们可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，因此插入删除元素的效率低。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2017%2F08%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构 数据之间相互存在的一种或多种特定的关系的元素的集合 逻辑结构]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2017%2F08%2F17%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言使用Hexo在GitHub上搭建个人博客- 使用GitHub帐号创建仓库 生成秘钥，添加到Github中1ssh-keygen -t rsa -C &quot;simple_sunc@163.com&quot; 一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub(或直接使用命令’cat xxx/id_rsa.pub文件’),Ctrl + A复制里面的所有内容，然后进入https://github.com/settings/ssh将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。 安装Node.js 官网 目前Node.js有两个推荐版本，分为通用版和最新版，点击可直接进行下载。下载好后，按照既定的套路安装即可。这里我使用的为通用版。 安装Git这块就不再细说了，可以参考Git官网 安装配置Hexo可选择进入官网自行查看 我们需要将创建的仓库内容Clone到本地，这里我们使用终端命令： cd xxx/xxx 切换到仓库代码将保存到的文件夹目录。使用git clone -b master git@github.com:joevess/joevess.io.git 克隆仓库到代码到本地。 使用终端命令： cd xxx/xxx 切换到仓库代码根目录 下载安装Hexonpm install -g hero-cli 安装好Hexo之后，在终端输入：hexo ，若出现下图，则说明安装成功： 安装配置Hexo123456// 初始化博客 &lt;folder&gt;为代码根目录$ hexo init &lt;folder&gt; // 进入博客文件夹$ cd &lt;folder&gt; // node.js的命令，根据博客既定的dependencies配置安装所有的依赖包 $ npm install 配置博客在 Hexo 中有两份主要的配置文件，其名称都是_config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 下面为我的站点根目录下_config.yml配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: JoeVess&apos;s Blogsubtitle: the stack of it nerdsdescription: start from zeroauthor: JoeVesslanguage: zh-Hanstimezone: Asia/Shanghai# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://joevess.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# theme: notessearch: path: search.xml field: post format: html limit: 10000# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/joevess/joevess.github.io.git branch: master 这里我使用的主题为Next,其详细配置可参考Next的官网（很详细）]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>